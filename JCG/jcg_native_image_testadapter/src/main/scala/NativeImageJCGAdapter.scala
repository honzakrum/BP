import java.io.Writer
import java.nio.file.{Files, Paths, Path}
import scala.sys.process._
import scala.util.{Try, Success, Failure}

object NativeImageJCGAdapter extends JavaTestAdapter {

    // Implementation
    val frameworkName: String = "NativeImage"

    val possibleAlgorithms: Array[String] = Array("RTA") // points-to, RTA

    def serializeCG(
        algorithm:      String,
        inputDirPath:   String,
        output:         Writer,
        adapterOptions: AdapterOptions
    ): Long = {
        val startTime = System.nanoTime()

        println(s"Input: $inputDirPath")
        val graalJavaPath = Paths.get("/home/krumi/.sdkman/candidates/java/25.ea.8-graal/bin/java")
        val nativeImagePath = Paths.get("/home/krumi/.sdkman/candidates/java/25.ea.8-graal/bin/native-image")

        val configDirectory = Paths.get("./config")

        val jarPath = Paths.get(inputDirPath)
        val jarFileName = jarPath.getFileName.toString
        val configOutputDir = configDirectory.resolve(jarFileName.stripSuffix(".jar"))

        // Create configuration files that could be necessary for reflection etc
        createConfig(jarPath, configOutputDir, graalJavaPath)

        // Generate call graph for current test case
        //generateCallGraph(jarPath, configDirectory, nativeImagePath)

        // Cleanup
        //cleanArtifact(jarFileName)

        // TODO output serialised json call graphs
        output.close()

        System.nanoTime() - startTime
    }

    /**
     * Generates configuration files using the native-image-agent to their respective folder.
     *
     * @param jarFile         The path to the JAR file.
     * @param configOutputDir The directory to store the configuration files.
     * @param graalJavaPath The path to Native Image executable.
     */
    def createConfig(jarFile: Path, configOutputDir: Path, graalJavaPath: Path): Unit = {
        println(s"Creating directory ${configOutputDir.toString}")
        Files.createDirectories(configOutputDir)
        val agentCommand = Seq(
            graalJavaPath.toString,
            s"-agentlib:native-image-agent=config-output-dir=${configOutputDir.toString}",
            "-jar",
            jarFile.toString
        )

        println(s"Running agent command: ${agentCommand.mkString(" ")}")
        val agentResult = Try(agentCommand.!!)
        agentResult match {
            case Success(_) => println(s"Configuration generated for ${jarFile.getFileName}")
            case Failure(e) => println(s"Failed to generate configuration for ${jarFile.getFileName}: ${e.getMessage}")
        }
    }

    /**
     * Generates the call graph using the native-image tool.
     *
     * @param jarFile         The path to the JAR file.
     * @param configOutputDir The directory containing the configuration files.
     * @param nativeImagePath The path to Native Image executable.
     */
    def generateCallGraph(jarFile: Path, configOutputDir: Path, nativeImagePath : Path): Unit = {
       val nativeImageCommand = Seq(
            nativeImagePath.toString,
            "-H:+UnlockExperimentalVMOptions",
            "-H:PrintAnalysisCallTreeType=CSV",
            s"-H:ConfigurationFileDirectories=${configOutputDir.toString}",
            "-jar",
            jarFile.toString
        )

        println(s"Running native-image command: ${nativeImageCommand.mkString(" ")}")
        val nativeImageResult = Try(nativeImageCommand.!!)
        nativeImageResult match {
            case Success(output) =>
                println(s"Call graph generated for ${jarFile.getFileName}:\n$output")
            case Failure(e) => println(s"Failed to generate call graph for ${jarFile.getFileName}: ${e.getMessage}")
        }
    }

    /**
     * Deletes the executable artifact generated by the native-image tool.
     *
     * @param jarFileName The name of the JAR file (used to derive the executable name).
     */
    def cleanArtifact(jarFileName: String): Unit = {
        val executableName = jarFileName.stripSuffix(".jar") // Name of the executable
        val executablePath = Paths.get(executableName) // Path to the executable
        if (Files.exists(executablePath)) {
            println(s"Deleting executable artifact: $executableName")
            Files.delete(executablePath) // Delete the executable
        }
    }
}
